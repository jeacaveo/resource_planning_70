# -*- encoding: utf-8 -*-
##############################################################################
#
#    OpenERP, Open Source Management Solution
#    This module copyright (C) 2013 Therp BV (<http://therp.nl>)
#    All Rights Reserved
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
##############################################################################

from datetime import datetime, timedelta
from openerp.tools.misc import DEFAULT_SERVER_DATETIME_FORMAT,\
        DEFAULT_SERVER_DATE_FORMAT
from openerp.tools.translate import _
from openerp.osv.orm import Model, except_orm
from openerp.osv import fields


class resource_planning(object):
    '''Mixin class for objects that reference several resources.'''

    _resource_fields = []
    '''The object's fields that reference resources'''

    _date_field = 'date'
    '''The dateitime field for which to check availability'''

    _duration_field = 'duration'
    '''A float field indicating the duration in hours'''

    _end_date_field = None
    '''Alternative to _duration_field'''

    def _get_start_date(self, cr, uid, ids, context=None):
        '''Return the start date of the current object as datetime'''
        assert len(ids) == 1
        for this in self.browse(cr, uid, ids, context):
            return datetime.strptime(this[self._date_field],
                    DEFAULT_SERVER_DATETIME_FORMAT)

    def _get_end_date(self, cr, uid, ids, context=None):
        '''Return the end date of the current object as datetime'''
        assert len(ids) == 1
        for this in self.browse(cr, uid, ids, context):
            if self._end_date_field:
                return datetime.strptime(
                        this[self._end_date_field] or this[self._date_field],
                        DEFAULT_SERVER_DATETIME_FORMAT)
            else:
                return (datetime.strptime(this[self._date_field],
                        DEFAULT_SERVER_DATETIME_FORMAT) +
                        timedelta(hours=this.duration))

    def _get_availability_sql(self):
        '''Return a SQL statement to select the amount of objects which are
        booked for a time span.
        Needs to be executed with params dictionary:
            {
            'start_date': ...,
            'end_date': ...,
            'id': ...,
            }'''
        return '''select count(*) from %s where (%s, %s) 
            overlaps (%%(start_date)s, %%(end_date)s)
            and id != %%(id)s''' % (
                    self._table,
                    self._date_field, 
                    self._end_date_field or
                        "%s + cast(%s || ' hours' as interval)" %
                        (self._date_field, self._duration_field),

                    )

    def _get_availability_sql_resource_fragment(self):
        '''Return a fragment of a where clause selecting objects which are
        booked for the same resource(s).
        Needs to be executed with params dictionary:
            {
            [_resource_fields[0]]: ...,
            ...,
            }'''
        return (
                (' and (' if self._resource_fields else '') +
                ' or '.join(
                    [self._get_availability_sql_resource_field_fragment(field)
                        for field in self._resource_fields]) +
                (')' if self._resource_fields else '')
                )

    def _get_availability_sql_resource_field_fragment(self, resource_field):
        '''Return the check to be done for selecting objects which are booked
        for the resource referenced by resource_field
        Return value contains %(resource_field)s to be replaced by
        resource_field's value
        '''
        return resource_field + '=%(' + resource_field + ')s'

    def _get_sql_parameter_dict(self, cr, uid, ids, context=None):
        '''Return a dict that can be passed to a cursur executing sql
        generated by _get_*sql'''
        assert len(ids) == 1
        for this in self.browse(cr, uid, ids, context):
            return dict(
                [(field, this[field].id or None)
                    for field in self._resource_fields],
                start_date=this._get_start_date(),
                end_date=this._get_end_date(), id=this.id)

    def _check_availability(self, cr, uid, ids, context=None,
            raise_except_orm=True):
        '''Check if the object can be scheduled at its given time and its
        occupied resources'''
        if context is None:
            context = {}
        if context.get('_no_check_availability'):
            return True
        for this in self.browse(cr, uid, ids, context):
            cr.execute(
                self._get_availability_sql() +
                self._get_availability_sql_resource_fragment(),
                this._get_sql_parameter_dict())
            if cr.fetchall()[0][0]:
                #there are overlaps - this can still be okay if the overlapping
                #resources have a time_efficiency > 1 and are not overbooked
                for field in self._resource_fields:
                    cr.execute(
                            self._get_availability_sql() +
                            ' and ' +
                            self._get_availability_sql_resource_field_fragment(
                                field),
                            this._get_sql_parameter_dict())
                    if cr.fetchall()[0][0] >= this[field].time_efficiency:
                        #if raise_except_orm:
                        #    raise except_orm(_('Error'), _('%s can only be '
                        #        'booked %d time(s) in the same period!') % (
                        #            this[field].name,
                        #            this[field].time_efficiency))
                        #return False
                        return True

            for field in self._resource_fields:
                if not this[field].calendar_id:
                    continue

                #verify that all resources are bookable and don't have vacation
                if (self.pool.get('resource.calendar')._interval_hours_get(cr,
                        uid, this[field].calendar_id.id,
                        this._get_start_date(), this._get_end_date(),
                        this[field].resource_id.id,
                        timezone_from_uid=uid,
                        )
                        < (this._get_end_date() - 
                            this._get_start_date()).total_seconds() / 3600):
                    if raise_except_orm:
                        raise except_orm(_('Error'), _('%s cannot be '
                            'booked at %s!') % (
                            this[field].name,
                            fields.datetime.context_timestamp(cr, uid,
                                    this._get_start_date(), context).strftime(
                                        DEFAULT_SERVER_DATETIME_FORMAT)))
                    return False
        return True

    def _assert_availability(self, cr, uid, ids, context=None):
        if context is None:
            context = {}

        for this in self.browse(cr, uid, ids, context):
            if not this._check_availability():
                raise except_orm(_('Error'), _('%s cannot be booked at %s') %
                        (this.name_get()[0][1], 
                            datetime.strftime(
                                fields.datetime.context_timestamp(cr, uid,
                                    datetime.strptime(this[self._date_field],
                                        DEFAULT_SERVER_DATETIME_FORMAT),
                                    context),
                                DEFAULT_SERVER_DATETIME_FORMAT)))

    def get_leaves(self, cr, uid, date_from, date_to, context=None):
        '''Return leaves for given interval, partitioned in days with date as
        key'''
        result = {}
        date_from = datetime.strptime(date_from, DEFAULT_SERVER_DATE_FORMAT)\
                .date()
        date_to = datetime.strptime(date_to, DEFAULT_SERVER_DATE_FORMAT)\
                .date() + timedelta(days=1)

        cr.execute('''select
            date_from, date_to, resource_object_id, resource_field
            from resource_calendar_leaves
            join (%s) _resources
            on resource_calendar_leaves.resource_id=_resources.resource_id
            where
                (%%(date_from)s, %%(date_to)s) overlaps (date_from, date_to)
            ''' % ' union '.join(
                [
                    'select id as resource_object_id, ' +
                    ('resource_id' if
                        'resource_id' in self.pool.get(
                            self._columns[resource_field]._obj)._columns
                    else 'id') + ' as resource_id, ' +
                    "'" + resource_field + "' as resource_field" +
                    ' from ' +
                    self.pool.get(self._columns[resource_field]._obj)._table
                    for resource_field in self._resource_fields
                ]),
            {
                'date_from': date_from,
                'date_to': date_to,
            })

        def iterate_days(date_from, date_to):
            date_current = date_from
            while date_current <= date_to:
                yield date_current
                date_current += timedelta(days=1)

        for row in cr.fetchall():
            leave_date_from = datetime.strptime(
                    row[0], DEFAULT_SERVER_DATETIME_FORMAT).date()
            leave_date_to = datetime.strptime(
                    row[1], DEFAULT_SERVER_DATETIME_FORMAT).date()

            for date in iterate_days(max(date_from, leave_date_from),
                    min(date_to, leave_date_to)):
                key = date.strftime(DEFAULT_SERVER_DATE_FORMAT)
                if key not in result:
                    result[key] = []
                model_obj = self.pool.get(self._columns[row[3]]._obj)
                name_tuple = model_obj.name_get(cr, uid, row[2], 
                                                context=context)[0]
                result[key].append(
                        {
                            'name': name_tuple[1],
                            'model': model_obj._name,
                            'id': name_tuple[0],
                        })

        return result
 
    def write(self, cr, uid, ids, vals, context=None):
        result = super(resource_planning, self).write(cr, uid, ids, vals, context)
        #for this in self.browse(
        #        cr, uid, ids if isinstance(ids, list) else [ids], context):
        #    this._assert_availability()
        return result

    def create(self, cr, uid, vals, context=None):
        id = super(resource_planning, self).create(cr, uid, vals, context)
        # self.browse(cr, uid, id, context)._assert_availability()
        return id

    def fields_view_get(self, cr, uid, view_id=None, view_type='form',
                        context=None, toolbar=False, submenu=False):
        result = super(resource_planning, self).fields_view_get(
                cr, uid, view_id, view_type, context, toolbar, submenu)

        if view_type == 'calendar':
            fields = self.fields_get(cr, uid, None, context)
            for resource_field in self._resource_fields:
                if resource_field not in result['fields']:
                    result['fields'][resource_field] = fields[resource_field]

        return result
